rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // ============================================
    // üîß HELPER FUNCTIONS
    // ============================================
    
    // Check if user is authenticated
    function isSignedIn() {
      return request.auth != null;
    }
    
    // Check for admin custom claim
    function isAdmin() {
      return request.auth != null && request.auth.token.admin == true;
    }
    
    // Check if user owns the memorial (creator or createdBy)
    function isOwner(memorialId) {
      return request.auth != null && (
        request.auth.uid == get(/databases/$(database)/documents/memorials/$(memorialId)).data.creatorUid ||
        request.auth.uid == get(/databases/$(database)/documents/memorials/$(memorialId)).data.createdByUserId
      );
    }
    
    // Check if user is a family member of the memorial
    function isFamilyMember(memorialId) {
      return request.auth != null && 
        exists(/databases/$(database)/documents/memorials/$(memorialId)/familyMembers/$(request.auth.uid));
    }
    
    // Check if user is an approved funeral director
    function isApprovedFuneralDirector() {
      return request.auth != null && 
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'FuneralDirector' &&
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.approved == true;
    }
    
    // Combined check for edit permissions
    function canEditMemorial(memorialId) {
      return isAdmin() || isOwner(memorialId) || isFamilyMember(memorialId) || isApprovedFuneralDirector();
    }
    
    // Check if only updating allowed photo fields
    function onlyUpdatingPhotoFields() {
      let changedFields = request.resource.data.diff(resource.data).affectedKeys();
      // Allow updates to photos, photoMetadata, and updatedAt fields
      return changedFields.hasOnly(['photos', 'photoMetadata', 'updatedAt']);
    }
    
    // Check if memorial is public
    function isPublicMemorial() {
      return resource.data.isPublic == true;
    }
    
    // ============================================
    // üë• USER DOCUMENTS
    // ============================================
    
    match /users/{userId} {
      // Admins can read/write any user document
      // Regular users can only read/write their own
      allow read, write: if isAdmin() || (isSignedIn() && request.auth.uid == userId);
    }
    
    // ============================================
    // üïØÔ∏è MEMORIAL DOCUMENTS
    // ============================================
    
    match /memorials/{memorialId} {
      // Read access: public memorials, owners, family members, admins, or checking existence for URL availability
      allow read: if isPublicMemorial() || canEditMemorial(memorialId) || 
        // Allow unauthenticated reads for URL availability checking (will return false for non-existent docs)
        request.auth == null;
      
      // List access: allow authenticated users to query memorials
      allow list: if isSignedIn();
      
      // Create: any authenticated user can create a memorial
      allow create: if isSignedIn();
      
      // Update: differentiated by user role
      allow update: if canEditMemorial(memorialId) && (
        // Owners and admins can update anything
        isAdmin() || isOwner(memorialId) ||
        // Family members can only update photo-related fields
        (isFamilyMember(memorialId) && onlyUpdatingPhotoFields())
      );
      
      // Delete: only owners and admins
      allow delete: if isAdmin() || isOwner(memorialId);
      
      // ============================================
      // üì∏ SLIDESHOW PHOTOS SUBCOLLECTION
      // ============================================
      
      match /slideshow/{photoId} {
        // Read: owners, admins, family members, and public if memorial is public
        allow read: if isPublicMemorial() || canEditMemorial(memorialId);
        
        // Create: owners, admins, and family members can upload photos
        allow create: if canEditMemorial(memorialId);
        
        // Update: owners, admins, and family members can update photo metadata
        allow update: if canEditMemorial(memorialId);
        
        // Delete: owners, admins, and family members can delete photos
        allow delete: if canEditMemorial(memorialId);
      }
      
      // ============================================
      // üë®‚Äçüë©‚Äçüëß‚Äçüë¶ FAMILY MEMBERS SUBCOLLECTION
      // ============================================
      
      match /familyMembers/{userId} {
        // Read: owners, admins, and the family member themselves
        allow read: if canEditMemorial(memorialId) || request.auth.uid == userId;
        
        // Write: only owners and admins can add/remove family members
        allow create, update, delete: if isOwner(memorialId) || isAdmin();
      }
      
      // ============================================
      // üë• FOLLOWERS SUBCOLLECTION
      // ============================================
      
      match /followers/{userId} {
        // Users can only manage their own follow status
        allow read, create, delete: if isSignedIn() && request.auth.uid == userId;
        // No updates allowed once following
        allow update: if false;
      }
    }
    
    // ============================================
    // ‚úâÔ∏è INVITATION DOCUMENTS
    // ============================================
    
    match /invitations/{invitationId} {
      // Read access: admins, sender, or recipient
      allow read: if isAdmin() ||
        (isSignedIn() && request.auth.uid == resource.data.invitedByUid) ||
        (isSignedIn() && request.auth.token.email == resource.data.inviteeEmail);
      
      // Create: only memorial owners can send invitations
      allow create: if isSignedIn() && 
        request.auth.uid == request.resource.data.invitedByUid &&
        isOwner(request.resource.data.memorialId);
      
      // Update: only recipients can accept invitations
      allow update: if isSignedIn() && 
        request.auth.token.email == resource.data.inviteeEmail &&
        request.resource.data.status == 'accepted' &&
        // Ensure only status and acceptedAt fields are being updated
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'acceptedAt']);
      
      // Delete: disabled for security (maintain audit trail)
      allow delete: if false;
    }
    
    // ============================================
    // üìä LIVESTREAM CONFIGURATIONS
    // ============================================
    
    match /livestreamConfigs/{configId} {
      // Read: allow authenticated users to read their own configs, and approved funeral directors to read all configs
      allow read: if isSignedIn() && (
        // Users can read their own configs
        request.auth.uid == resource.data.creatorUid ||
        // Approved funeral directors can read all configs for livestreaming purposes
        isApprovedFuneralDirector() ||
        // Admins can read all configs
        isAdmin()
      );
      
      // Create: allow authenticated users to create livestream configs
      allow create: if isSignedIn();
      
      // Update: prevent updates if payment status is 'paid', except for payment status updates and livestream status
      allow update: if isSignedIn() && (
        // Allow payment status updates (for completing payments)
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['paymentStatus', 'paymentIntentId', 'paidAt', 'updatedAt']) ||
        // Allow livestream status updates by approved funeral directors
        (isApprovedFuneralDirector() && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['isLive', 'streamStartTime', 'streamEndTime', 'viewerCount', 'updatedAt'])) ||
        // Allow other updates only if not paid yet
        resource.data.paymentStatus != 'paid'
      );
      
      // Delete: allow authenticated users to delete their own configs (only if not paid)
      allow delete: if isSignedIn() && resource.data.paymentStatus != 'paid';
    }
    
    // ============================================
    // üì∏ PHOTO UPLOAD LOGS
    // ============================================
    
    match /photoUploads/{uploadId} {
      // Read: admins and memorial editors
      allow read: if isAdmin() || 
        (resource.data.memorialId != null && canEditMemorial(resource.data.memorialId));
      
      // Create: handled by server-side functions only
      allow create: if false;
      
      // No updates or deletes allowed (audit trail)
      allow update, delete: if false;
    }
    
    // ============================================
    // üìà ANALYTICS (read-only for clients)
    // ============================================
    
    match /analytics/{docId} {
      allow read: if isAdmin();
      allow write: if false; // Server-side only
    }
    
    // ============================================
    // üîç AUDIT LOGS (read-only for clients)
    // ============================================
    
    match /auditLogs/{logId} {
      allow read: if isAdmin();
      allow write: if false; // Server-side only
    }
  }
}